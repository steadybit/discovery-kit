/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {}

export interface components {
	schemas: {
		/**
		 * Discovery List
		 * @description Lists all discoveries that the platform/agent could execute.
		 */
		DiscoveryList: {
			discoveries: components['schemas']['DescribingEndpointReference'][];
			targetTypes: components['schemas']['DescribingEndpointReference'][];
			targetAttributes: components['schemas']['DescribingEndpointReference'][];
		};
		/**
		 * Discovery Description
		 * @description Provides details about a discovery, e.g., what endpoint needs to be called to discover targets.
		 */
		DiscoveryDescription: {
			/** @description A technical ID that is used to uniquely identify this type of discovery. You will typically want to use something like `org.example.discoveries.my-fancy-discovery`. */
			id: string;
			discover: components['schemas']['DescribingEndpointReferenceWithCallInterval'];
			/**
			 * @description If the agent is deployed as a daemonset in Kubernetes, should the discovery only be called from the leader agent? This can be helpful to avoid duplicate targets for every running agent. You may alternatively define that the discovery should run only for Steadybit agents operating within the AWS agent mode (as defined by the `STEADYBIT_AGENT_MODE` Steadybit agent environment variable / the `agent.mode` Steadybit agent Helm chart value).
			 * @enum {string}
			 */
			restrictTo?: 'ANY' | 'LEADER' | 'AWS';
		};
		/**
		 * Error
		 * @description RFC 7807 Problem Details for HTTP APIs compliant response body for error scenarios
		 */
		DiscoveryKitError: {
			/** @description A URI reference that identifies the problem type. */
			type?: string;
			/** @description A short, human-readable summary of the problem type. */
			title: string;
			/** @description A human-readable explanation specific to this occurrence of the problem. */
			detail?: string;
			/** @description A URI reference that identifies the specific occurrence of the problem. */
			instance?: string;
		};
		/**
		 * HTTP Endpoint Reference
		 * @description HTTP endpoint which the Steadybit platform/agent could communicate with.
		 */
		DescribingEndpointReference: {
			/** @description Absolute path of the HTTP endpoint. */
			path: string;
			/**
			 * @description HTTP method to use when calling the HTTP endpoint.
			 * @enum {string}
			 */
			method: 'GET';
		};
		/**
		 * HTTP Endpoint Reference
		 * @description HTTP endpoint which the Steadybit platform/agent could communicate with.
		 */
		DescribingEndpointReferenceWithCallInterval: components['schemas']['DescribingEndpointReference'] & {
			/** @description At what frequency should the state endpoint be called? Takes durations in the format of `100ms` or `10s`. */
			callInterval?: string;
		};
		PluralLabel: {
			one: string;
			other: string;
		};
		AttributeDescription: {
			/** @description The attribute name, for example `cat.name` */
			attribute: string;
			label: components['schemas']['PluralLabel'];
		};
		AttributeDescriptions: {
			attributes: components['schemas']['AttributeDescription'][];
		};
		/** @description A single discovered target */
		Target: {
			/** @description The id of the target, needs to be unique per agent and target type. */
			id: string;
			/** @description A label, which will be used by the platform to display the target */
			label: string;
			/** @description The type of the target. Will be used to find matching attacks and find the right ui configuration to show and select the targets. */
			targetType: string;
			/** @description These attributes include detailed information about the target provided through the discovery. These attributes are typically used as additional parameters within the attack implementation. */
			attributes: { [key: string]: string[] };
		};
		/** @description The results of a discovery call */
		DiscoveredTargets: {
			targets: components['schemas']['Target'][];
		};
		OrderBy: {
			attribute: string;
			/** @enum {string} */
			direction: 'ASC' | 'DESC';
		};
		Column: {
			/** @description The attribute which should be displayed in the column. */
			attribute: string;
			/** @description If the given attribute is empty, the fallbackAttributes are used. The first non-empty attribute will be displayed. */
			fallbackAttributes?: string[];
		};
		Table: {
			columns: components['schemas']['Column'][];
			orderBy: components['schemas']['OrderBy'][];
		};
		Attribute: {
			name: string;
			/** @enum {string} */
			matcher: 'equals' | 'contains' | 'starts_with';
		};
		SourceOrDestination: {
			/** @description The source or destination target type. */
			type: string;
			/** @description To identify a source or a destination, we employ a mechanism similar to Kubernetes label selectors. When this instance represents a source, you can use the placeholder `${src.attribute}` to refer to target attributes of the destination. Note that you can use the placeholders `${src.attribute}` and `${dest.attribute}` respectively. */
			selector: { [key: string]: string };
		};
		TargetEnrichmentRule: {
			src: components['schemas']['SourceOrDestination'];
			dest: components['schemas']['SourceOrDestination'];
			attributes: components['schemas']['Attribute'][];
		};
		/** @description A definition of a target type and how it will be handled by the ui */
		TargetDescription: {
			/** @description a global unique name of the target type */
			id: string;
			/** @description The version of the target type. Remember to increase the value everytime you update the definitions. The platform will ignore any definition changes with the same version. We do recommend usage of semver strings. */
			version: string;
			label: components['schemas']['PluralLabel'];
			/** @description A human readable label categorizing the target type, e.g., 'cloud' or 'Kubernetes'. */
			category?: string;
			/** @description An icon that is used to identify the targets in the ui. Needs to be a data-uri containing an image. */
			icon?: string;
			table: components['schemas']['Table'];
			enrichmentRules?: components['schemas']['TargetEnrichmentRule'][];
		};
	};
	responses: {
		/** Response for the discovery list endpoint */
		DiscoveryListResponse: {
			content: {
				'application/json': Partial<components['schemas']['DiscoveryList']> &
					Partial<components['schemas']['DiscoveryKitError']>;
			};
		};
		/** Response for the describe discovery endpoint */
		DiscoveryDescriptionResponse: {
			content: {
				'application/json': Partial<components['schemas']['DiscoveryDescription']> &
					Partial<components['schemas']['DiscoveryKitError']>;
			};
		};
		/** Response for the describe attributes endpoint */
		DescribeAttributesResponse: {
			content: {
				'application/json': Partial<components['schemas']['AttributeDescriptions']> &
					Partial<components['schemas']['DiscoveryKitError']>;
			};
		};
		/** The results of a discovery call */
		TargetDiscoveryResponse: {
			content: {
				'application/json': Partial<components['schemas']['DiscoveredTargets']> &
					Partial<components['schemas']['DiscoveryKitError']>;
			};
		};
		/** The results of a discovery call */
		DescribeTargetResponse: {
			content: {
				'application/json': Partial<components['schemas']['TargetDescription']> &
					Partial<components['schemas']['DiscoveryKitError']>;
			};
		};
	};
}

export interface operations {}

export interface external {}
