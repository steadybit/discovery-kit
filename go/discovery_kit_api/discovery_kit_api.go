// Package discovery_kit_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.1-0.20220629212257-2cf7fcf5b26d DO NOT EDIT.
package discovery_kit_api

import (
	"encoding/json"
)

// Defines values for AttributeMatcher.
const (
	Contains   AttributeMatcher = "contains"
	Equals     AttributeMatcher = "equals"
	StartsWith AttributeMatcher = "starts_with"
)

// Defines values for DescribingEndpointReferenceMethod.
const (
	DescribingEndpointReferenceMethodGET DescribingEndpointReferenceMethod = "GET"
)

// Defines values for DescribingEndpointReferenceWithCallIntervalMethod.
const (
	DescribingEndpointReferenceWithCallIntervalMethodGET DescribingEndpointReferenceWithCallIntervalMethod = "GET"
)

// Defines values for DiscoveryDescriptionRestrictTo.
const (
	ANY    DiscoveryDescriptionRestrictTo = "ANY"
	LEADER DiscoveryDescriptionRestrictTo = "LEADER"
)

// Defines values for OrderByDirection.
const (
	ASC  OrderByDirection = "ASC"
	DESC OrderByDirection = "DESC"
)

// Attribute defines model for Attribute.
type Attribute struct {
	Matcher AttributeMatcher `json:"matcher"`
	Name    string           `json:"name"`
}

// AttributeMatcher defines model for Attribute.Matcher.
type AttributeMatcher string

// AttributeDescription defines model for AttributeDescription.
type AttributeDescription struct {
	// The attribute name, for example `cat.name`
	Attribute string      `json:"attribute"`
	Label     PluralLabel `json:"label"`
}

// AttributeDescriptions defines model for AttributeDescriptions.
type AttributeDescriptions struct {
	Attributes []AttributeDescription `json:"attributes"`
}

// Column defines model for Column.
type Column struct {
	// The attribute which should be displayed in the column.
	Attribute string `json:"attribute"`

	// If the given attribute is empty, the fallbackAttributes are used. The first non-empty attribute will be displayed.
	FallbackAttributes *[]string `json:"fallbackAttributes,omitempty"`
}

// HTTP endpoint which the Steadybit platform/agent could communicate with.
type DescribingEndpointReference struct {
	// HTTP method to use when calling the HTTP endpoint.
	Method DescribingEndpointReferenceMethod `json:"method"`

	// Absolute path of the HTTP endpoint.
	Path string `json:"path"`
}

// HTTP method to use when calling the HTTP endpoint.
type DescribingEndpointReferenceMethod string

// DescribingEndpointReferenceWithCallInterval defines model for DescribingEndpointReferenceWithCallInterval.
type DescribingEndpointReferenceWithCallInterval struct {
	// At what frequency should the state endpoint be called? Takes durations in the format of `100ms` or `10s`.
	CallInterval *string `json:"callInterval,omitempty"`

	// HTTP method to use when calling the HTTP endpoint.
	Method DescribingEndpointReferenceWithCallIntervalMethod `json:"method"`

	// Absolute path of the HTTP endpoint.
	Path string `json:"path"`
}

// HTTP method to use when calling the HTTP endpoint.
type DescribingEndpointReferenceWithCallIntervalMethod string

// The results of a discovery call
type DiscoveredTargets struct {
	Targets []Target `json:"targets"`
}

// Provides details about a discovery, e.g., what endpoint needs to be called to discover targets.
type DiscoveryDescription struct {
	// HTTP endpoint which the Steadybit platform/agent could communicate with.
	Discover DescribingEndpointReferenceWithCallInterval `json:"discover"`

	// A technical ID that is used to uniquely identify this type of discovery. You will typically want to use something like `org.example.discoveries.my-fancy-discovery`.
	Id string `json:"id"`

	// If the agent is deployed as a daemonset in Kubernetes, should the discovery only be called from the leader agent? This can be helpful to avoid duplicate targets for every running agent.
	RestrictTo *DiscoveryDescriptionRestrictTo `json:"restrictTo,omitempty"`
}

// If the agent is deployed as a daemonset in Kubernetes, should the discovery only be called from the leader agent? This can be helpful to avoid duplicate targets for every running agent.
type DiscoveryDescriptionRestrictTo string

// RFC 7807 Problem Details for HTTP APIs compliant response body for error scenarios
type DiscoveryKitError struct {
	// A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// A short, human-readable summary of the problem type.
	Title string `json:"title"`

	// A URI reference that identifies the problem type.
	Type *string `json:"type,omitempty"`
}

// Lists all discoveries that the platform/agent could execute.
type DiscoveryList struct {
	Discoveries      []DescribingEndpointReference `json:"discoveries"`
	TargetAttributes []DescribingEndpointReference `json:"targetAttributes"`
	TargetTypes      []DescribingEndpointReference `json:"targetTypes"`
}

// OrderBy defines model for OrderBy.
type OrderBy struct {
	Attribute string           `json:"attribute"`
	Direction OrderByDirection `json:"direction"`
}

// OrderByDirection defines model for OrderBy.Direction.
type OrderByDirection string

// PluralLabel defines model for PluralLabel.
type PluralLabel struct {
	One   string `json:"one"`
	Other string `json:"other"`
}

// SourceOrDestination defines model for SourceOrDestination.
type SourceOrDestination struct {
	// To identify a source or a destination, we employ a mechanism similar to Kubernetes label selectors. When this instance represents a source, you can use the placeholder `${src.attribute}` to refer to target attributes of the destination. Note that you can use the placeholders `${src.attribute}` and `${dest.attribute}` respectively.
	Selector map[string]string `json:"selector"`

	// The source or destination target type.
	Type string `json:"type"`
}

// Table defines model for Table.
type Table struct {
	Columns []Column  `json:"columns"`
	OrderBy []OrderBy `json:"orderBy"`
}

// A single discovered target
type Target struct {
	// These attributes include detailed information about the target provided through the discovery. These attributes are typically used as additional parameters within the attack implementation.
	Attributes map[string][]string `json:"attributes"`

	// The id of the target, needs to be unique per agent and target type.
	Id string `json:"id"`

	// A label, which will be used by the platform to display the target
	Label string `json:"label"`

	// The type of the target. Will be used to find matching attacks and find the right ui configuration to show and select the targets.
	TargetType string `json:"targetType"`
}

// A definition of a target type and how it will be handled by the ui
type TargetDescription struct {
	// A human readable label categorizing the target type, e.g., 'cloud' or 'Kubernetes'.
	Category        *string                 `json:"category,omitempty"`
	EnrichmentRules *[]TargetEnrichmentRule `json:"enrichmentRules,omitempty"`

	// An icon that is used to identify the targets in the ui. Needs to be a data-uri containing an image.
	Icon *string `json:"icon,omitempty"`

	// a global unique name of the target type
	Id    string      `json:"id"`
	Label PluralLabel `json:"label"`
	Table Table       `json:"table"`

	// The version of the target type. Remember to increase the value everytime you update the definitions. The platform will ignore any definition changes with the same version. We do recommend usage of semver strings.
	Version string `json:"version"`
}

// TargetEnrichmentRule defines model for TargetEnrichmentRule.
type TargetEnrichmentRule struct {
	Attributes []Attribute         `json:"attributes"`
	Dest       SourceOrDestination `json:"dest"`
	Src        SourceOrDestination `json:"src"`
}

// DescribeAttributesResponse defines model for DescribeAttributesResponse.
type DescribeAttributesResponse struct {
	union json.RawMessage
}

// DescribeTargetResponse defines model for DescribeTargetResponse.
type DescribeTargetResponse struct {
	union json.RawMessage
}

// DiscoveryDescriptionResponse defines model for DiscoveryDescriptionResponse.
type DiscoveryDescriptionResponse struct {
	union json.RawMessage
}

// DiscoveryListResponse defines model for DiscoveryListResponse.
type DiscoveryListResponse struct {
	union json.RawMessage
}

// TargetDiscoveryResponse defines model for TargetDiscoveryResponse.
type TargetDiscoveryResponse struct {
	union json.RawMessage
}

func (t DescribeAttributesResponse) AsAttributeDescriptions() (AttributeDescriptions, error) {
	var body AttributeDescriptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeAttributesResponse) FromAttributeDescriptions(v AttributeDescriptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeAttributesResponse) AsDiscoveryKitError() (DiscoveryKitError, error) {
	var body DiscoveryKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeAttributesResponse) FromDiscoveryKitError(v DiscoveryKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeAttributesResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DescribeAttributesResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t DescribeTargetResponse) AsTargetDescription() (TargetDescription, error) {
	var body TargetDescription
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeTargetResponse) FromTargetDescription(v TargetDescription) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeTargetResponse) AsDiscoveryKitError() (DiscoveryKitError, error) {
	var body DiscoveryKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeTargetResponse) FromDiscoveryKitError(v DiscoveryKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeTargetResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DescribeTargetResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t DiscoveryDescriptionResponse) AsDiscoveryDescription() (DiscoveryDescription, error) {
	var body DiscoveryDescription
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DiscoveryDescriptionResponse) FromDiscoveryDescription(v DiscoveryDescription) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DiscoveryDescriptionResponse) AsDiscoveryKitError() (DiscoveryKitError, error) {
	var body DiscoveryKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DiscoveryDescriptionResponse) FromDiscoveryKitError(v DiscoveryKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DiscoveryDescriptionResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscoveryDescriptionResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t DiscoveryListResponse) AsDiscoveryList() (DiscoveryList, error) {
	var body DiscoveryList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DiscoveryListResponse) FromDiscoveryList(v DiscoveryList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DiscoveryListResponse) AsDiscoveryKitError() (DiscoveryKitError, error) {
	var body DiscoveryKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DiscoveryListResponse) FromDiscoveryKitError(v DiscoveryKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DiscoveryListResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscoveryListResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t TargetDiscoveryResponse) AsDiscoveredTargets() (DiscoveredTargets, error) {
	var body DiscoveredTargets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *TargetDiscoveryResponse) FromDiscoveredTargets(v DiscoveredTargets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t TargetDiscoveryResponse) AsDiscoveryKitError() (DiscoveryKitError, error) {
	var body DiscoveryKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *TargetDiscoveryResponse) FromDiscoveryKitError(v DiscoveryKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t TargetDiscoveryResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TargetDiscoveryResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
func Ptr[T any](val T) *T {
	return &val
}